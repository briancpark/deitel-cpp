<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><TITLE>IAsyncReader Interface</TITLE>
<STYLE>
<!--
.tctop {color: blue}
.cpslug {color: blue; text-decoration: none}
-->
</STYLE>
<SCRIPT LANGUAGE="JAVASCRIPT">
//<!--
function ShowButtons() {
    if (window.top.frames.length!=0 && window.top.frames[0].ShowButtons!=null)
	window.top.frames[0].ShowButtons('/dssd0113.htm','/dssd0000.htm','/dssd0088.htm','/index.htm','/dssd0115.htm');
}
ShowButtons();
//-->
</SCRIPT>
</HEAD>
<BODY onLoad="ShowButtons()" TOPMARGIN=10 BGPROPERTIES="FIXED" BGCOLOR="#FFFFFF" LINK="#000000" VLINK="#808080" ALINK="#000000">
<FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">
<H2><A NAME="If_000106011a000000">IAsyncReader Interface</A></H2>
<BR CLEAR=ALL>
<P>The <B>IAsyncReader</B> interface allows multiple overlapped reads from
different positions in the media stream. This interface is supported by source filters.

<P>Note that during connection an output pin supporting the <B>IAsyncReader</B>
should check whether its <A HREF="dssd0175.htm#If_0001060157030200" TARGET="TEXT">QueryInterface</A> method is called asking for
the <B>IAsyncReader</B> interface. If it is not, then the output pin
should fail the connect unless it establishes some other transport to use
during the connection.

<A NAME="If_000106011a010000"></A><P><B>When to Implement</B>
<P>Implement this interface on a pin if your filter reads data of media type
MEDIATYPE_Stream from some source.

<A NAME="If_000106011a020000"></A><P><B>When to Use</B>
<P>A parser, such as an Apple&#174; QuickTime&#174; parser filter, can use this interface to read from a
filter that reads from a file, the network, or memory.

<A NAME="If_000106011a030000"></A><P><B>Methods in Vtable Order</B>
<TABLE BORDER=0>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><B>IUnknown methods </B></FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><B>Description
</B></FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="dssd0175.htm#If_0001060157030200" TARGET="TEXT">QueryInterface</A> </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Retrieves pointers to supported interfaces.
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="dssd0175.htm#If_0001060157030100" TARGET="TEXT">AddRef</A> </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Increments the reference count.
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="dssd0175.htm#If_0001060157030300" TARGET="TEXT">Release</A> </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Decrements the reference count.
</FONT></TD></TR></TABLE>
<TABLE BORDER=0>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><B>IAsyncReader methods </B></FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><B>Description
</B></FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="dssd0114.htm#If_000106011a030500" TARGET="TEXT">RequestAllocator</A>
 </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Retrieves the actual allocator to be used.
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="dssd0114.htm#If_000106011a030400" TARGET="TEXT">Request</A>
 </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Queues a request for data.
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="dssd0114.htm#If_000106011a030800" TARGET="TEXT">WaitForNext</A>
 </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Blocks until the next sample is completed or the time-out occurs.
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="dssd0114.htm#If_000106011a030700" TARGET="TEXT">SyncReadAligned</A>
 </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Performs an aligned synchronized read.
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="dssd0114.htm#If_000106011a030600" TARGET="TEXT">SyncRead</A>
 </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Performs a synchronized read.
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="dssd0114.htm#If_000106011a030300" TARGET="TEXT">Length</A>
 </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Retrieves the total length of the stream, and the currently available length.
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="dssd0114.htm#If_000106011a030100" TARGET="TEXT">BeginFlush</A>
 </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Causes all outstanding reads to return.
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="dssd0114.htm#If_000106011a030200" TARGET="TEXT">EndFlush</A>
 </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Ends the flushing operation.
</FONT></TD></TR></TABLE>
<H3><HR COLOR=#0000FF><A NAME="If_000106011a030100">IAsyncReader::BeginFlush</A></H3>
<A HREF="dssd0114.htm" TARGET="TEXT">IAsyncReader Interface</A>
<P>Starts the flushing operation.


<P><B>HRESULT</B> <B>BeginFlush</B><B>(</B><B>void</B><B>)</B><B>;</B><BR><H5>Return Values</H5>
<P>Returns an <A HREF="dssd0293.htm#errcodes_0001060a01000001" TARGET="TEXT">HRESULT</A> value.


<H5>Remarks</H5>
<P>Causes all outstanding reads to return, possibly with a failure code
(<A HREF="dssd0293.htm#errcodes_0001060a01000057" TARGET="TEXT">VFW_E_TIMEOUT</A>), indicating that the outstanding reads were canceled.
Between <B>IAsyncReader::BeginFlush</B> and <A HREF="dssd0114.htm#If_000106011a030200" TARGET="TEXT">IAsyncReader::EndFlush</A> calls,
<A HREF="dssd0114.htm#If_000106011a030400" TARGET="TEXT">IAsyncReader::Request</A> calls will fail and <A HREF="dssd0114.htm#If_000106011a030800" TARGET="TEXT">IAsyncReader::WaitForNext</A>
calls will always complete immediately.
<H3><HR COLOR=#0000FF><A NAME="If_000106011a030200">IAsyncReader::EndFlush</A></H3>
<A HREF="dssd0114.htm" TARGET="TEXT">IAsyncReader Interface</A>
<P>Completes the flushing operation.

<P><B>HRESULT</B> <B>EndFlush</B><B>(</B><B>void</B><B>)</B><B>;</B><BR><H5>Return Values</H5>
<P>Returns an <A HREF="dssd0293.htm#errcodes_0001060a01000001" TARGET="TEXT">HRESULT</A> value.


<H5>Remarks</H5>
<P>Between <A HREF="dssd0114.htm#If_000106011a030100" TARGET="TEXT">IAsyncReader::BeginFlush</A> and <B>IAsyncReader::EndFlush</B> calls,
<A HREF="dssd0114.htm#If_000106011a030400" TARGET="TEXT">IAsyncReader::Request</A> calls will fail and <A HREF="dssd0114.htm#If_000106011a030800" TARGET="TEXT">IAsyncReader::WaitForNext</A> calls
will always complete immediately. This method is called so the source thread can wait in the
<B>IAsyncReader::WaitForNext</B> method again.
<H3><HR COLOR=#0000FF><A NAME="If_000106011a030300">IAsyncReader::Length</A></H3>
<A HREF="dssd0114.htm" TARGET="TEXT">IAsyncReader Interface</A>
<P>Retrieves the stream's total length, and the currently available length.

<P><B>HRESULT</B> <B>Length</B><B>(</B><BR>&nbsp;&nbsp;<B>LONGLONG*</B> <I>pTotal</I><B>,</B><BR>&nbsp;&nbsp;<B>LONGLONG*</B> <I>pAvailable</I><BR>&nbsp;&nbsp;<B>)</B><B>;</B><BR><H5>Parameters</H5>
<DL><DT><I>pTotal</I>
 </DT><DD>Total allocated length.
</DD><DT><I>pAvailable</I>
 </DT><DD>Available length.
</DD></DL>
<H5>Return Values</H5>
<P>Returns an <A HREF="dssd0293.htm#errcodes_0001060a01000001" TARGET="TEXT">HRESULT</A> value.


<H5>Remarks</H5>
<P>Read operations beyond the available length but within the total length will
normally succeed, but they might block for a long period of time.
<H3><HR COLOR=#0000FF><A NAME="If_000106011a030400">IAsyncReader::Request</A></H3>
<A HREF="dssd0114.htm" TARGET="TEXT">IAsyncReader Interface</A>
<P>Queues a request for data.

<P><B>HRESULT</B> <B>Request</B><B>(</B><BR>&nbsp;&nbsp;<B>IMediaSample*</B> <I>pSample</I><B>,</B><BR>&nbsp;&nbsp;<B>DWORD</B> <I>dwUser</I><BR>&nbsp;&nbsp;<B>)</B><B>;</B><BR><H5>Parameters</H5>
<DL><DT><I>pSample</I>
 </DT><DD>Media sample being requested.
</DD><DT><I>dwUser</I>
 </DT><DD>[in] User context.
</DD></DL>
<H5>Return Values</H5>
<P>Returns an <A HREF="dssd0293.htm#errcodes_0001060a01000001" TARGET="TEXT">HRESULT</A> value.


<H5>Remarks</H5>
<P>Media sample start and stop times contain the requested absolute
byte position (start-inclusive and stop-exclusive).
This method might fail if the sample is not obtained from an agreed allocator or
if the start or stop position does not match the agreed alignment.
The samples allocated from the source pin's allocator might fail
<A HREF="dssd0156.htm#If_0001060144030400" TARGET="TEXT">IMediaSample::GetPointer</A> until after returning from
<A HREF="dssd0114.htm#If_000106011a030800" TARGET="TEXT">IAsyncReader::WaitForNext</A>.

<P>The stop position must be aligned, which means it might exceed duration.
On completion, the stop position will be corrected to the unaligned actual data.

<P>The <I>dwUser</I> parameter is used by the caller to identify the sample
that returned from the <A HREF="dssd0114.htm#If_000106011a030800" TARGET="TEXT">IAsyncReader::WaitForNext</A> method. It has no
meaning within <A HREF="dssd0114.htm" TARGET="TEXT">IAsyncReader</A> but could be used to track individual sample
information.
<H3><HR COLOR=#0000FF><A NAME="If_000106011a030500">IAsyncReader::RequestAllocator</A></H3>
<A HREF="dssd0114.htm" TARGET="TEXT">IAsyncReader Interface</A>
<P>Retrieves the actual allocator to be used.

<P><B>HRESULT</B> <B>RequestAllocator</B><B>(</B><BR>&nbsp;&nbsp;<B>IMemAllocator*</B> <I>pPreferred</I><B>,</B><BR>&nbsp;&nbsp;<B>ALLOCATOR_PROPERTIES*</B> <I>pProps</I><B>,</B><BR>&nbsp;&nbsp;<B>IMemAllocator</B> <B>**</B> <I>ppActual</I><BR>&nbsp;&nbsp;<B>)</B><B>;</B><BR><H5>Parameters</H5>
<DL><DT><I>pPreferred</I>
 </DT><DD>[in] Preferred allocator.
</DD><DT><I>pProps</I>
 </DT><DD>[in] Preferred allocator properties (size, count, and alignment).
</DD><DT><I>ppActual</I>
 </DT><DD>[out] Actual allocator used.
</DD></DL>
<H5>Return Values</H5>
<P>Returns an <A HREF="dssd0293.htm#errcodes_0001060a01000001" TARGET="TEXT">HRESULT</A> value.


<H5>Remarks</H5>
<P>The preferred allocator and preferred allocator properties must be passed in.
This method returns the actual allocator to be used.

<P><A HREF="dssd0160.htm#If_0001060148030400" TARGET="TEXT">IMemAllocator::GetProperties</A> should be called
on the returned allocator to learn the alignment and prefix chosen.
This allocator will not be committed and decommitted by
the asynchronous reader, only by the consumer.
This method must be called before calling <A HREF="dssd0114.htm#If_000106011a030400" TARGET="TEXT">IAsyncReader::Request</A>.
<H3><HR COLOR=#0000FF><A NAME="If_000106011a030600">IAsyncReader::SyncRead</A></H3>
<A HREF="dssd0114.htm" TARGET="TEXT">IAsyncReader Interface</A>
<P>Performs a synchronous read.

<P><B>HRESULT</B> <B>SyncRead</B><B>(</B><BR>&nbsp;&nbsp;<B>LONGLONG</B> <I>llPosition</I><B>,</B><BR>&nbsp;&nbsp;<B>LONG</B> <I>lLength</I><B>,</B><BR>&nbsp;&nbsp;<B>BYTE*</B> <I>pBuffer</I><BR>&nbsp;&nbsp;<B>)</B><B>;</B><BR><H5>Parameters</H5>
<DL><DT><I>llPosition</I>
 </DT><DD>[in] Absolute file position.
</DD><DT><I>lLength</I>
 </DT><DD>[in] Number of bytes required.
</DD><DT><I>pBuffer </I>
 </DT><DD>[out] Where the data is written.
</DD></DL>
<H5>Return Values</H5>
<P>Returns an <A HREF="dssd0293.htm#errcodes_0001060a01000001" TARGET="TEXT">HRESULT</A> value.


<H5>Remarks</H5>
<P>The <B>SyncRead</B> method works in a stopped state as well as in a running state.
The read is not necessarily aligned. This method fails if the read is beyond the actual total length.
<H3><HR COLOR=#0000FF><A NAME="If_000106011a030700">IAsyncReader::SyncReadAligned</A></H3>
<A HREF="dssd0114.htm" TARGET="TEXT">IAsyncReader Interface</A>
<P>Performs a synchronous read of the data.

<P><B>HRESULT</B> <B>SyncReadAligned</B><B>(</B><BR>&nbsp;&nbsp;<B>IMediaSample*</B> <I>pSample</I><BR>&nbsp;&nbsp;<B>)</B><B>;</B><BR><H5>Parameters</H5>
<DL><DT><I>pSample</I>
 </DT><DD>Sample to read.
</DD></DL>
<H5>Return Values</H5>
<P>Returns an <A HREF="dssd0293.htm#errcodes_0001060a01000001" TARGET="TEXT">HRESULT</A> value.


<H5>Remarks</H5>
<P>The sample passed in must have been acquired from the agreed allocator.
The start and stop positions must be aligned equivalent to an
<A HREF="dssd0114.htm#If_000106011a030400" TARGET="TEXT">IAsyncReader::Request</A>/<A HREF="dssd0114.htm#If_000106011a030800" TARGET="TEXT">IAsyncReader::WaitForNext</A> pair,
but may avoid the need for a thread on the source filter.
<H3><HR COLOR=#0000FF><A NAME="If_000106011a030800">IAsyncReader::WaitForNext</A></H3>
<A HREF="dssd0114.htm" TARGET="TEXT">IAsyncReader Interface</A>
<P>Blocks until the next read requested through
<A HREF="dssd0114.htm#If_000106011a030400" TARGET="TEXT">IAsyncReader::Request</A> completes or the time-out occurs.

<P><B>HRESULT</B> <B>WaitForNext</B><B>(</B><BR>&nbsp;&nbsp;<B>DWORD</B> <I>dwTimeout</I><B>,</B><BR>&nbsp;&nbsp;<B>IMediaSample**</B> <I>ppSample</I><B>,</B><BR>&nbsp;&nbsp;<B>DWORD</B> <B>*</B> <I>pdwUser</I><BR>&nbsp;&nbsp;<B>)</B><B>;</B><BR><H5>Parameters</H5>
<DL><DT><I>dwTimeout</I>
 </DT><DD>[in] Time-out in milliseconds; can be zero or INFINITE.
</DD><DT><I>ppSample</I>
 </DT><DD>[out] Completed sample.
</DD><DT><I>pdwUser</I>
 </DT><DD>User context.
</DD></DL>
<H5>Return Values</H5>
<P>Returns an <A HREF="dssd0293.htm#errcodes_0001060a01000001" TARGET="TEXT">HRESULT</A> value.


<H5>Remarks</H5>
<P>Samples may not be returned in order. If there is a read error
of any sort, a notification will already have been sent by the source filter,
and <A HREF="dssd0293.htm#errcodes_0001060a01000001" TARGET="TEXT">HRESULT</A> will be an error. If <I>ppSample</I> is not null,
a request has been completed with the result code returned.

<P>The <I>pdwUser</I> parameter returns the caller's context <A HREF="dssd0389.htm#external_00010a010900002b" TARGET="TEXT">DWORD</A>
corresponding to the sample returned.
<P><P><FONT FACE="MS SANS SERIF" SIZE="1" COLOR="BLACK">
<A CLASS=cpslug HREF="copyrite.htm" TARGET="TEXT">&#169; 1997 Microsoft Corporation. All rights reserved. Terms of Use.</A>
</FONT>
<BR CLEAR=ALL><P>
</FONT><P>
</BODY></HTML>
